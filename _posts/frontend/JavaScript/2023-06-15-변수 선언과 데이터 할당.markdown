---
layout: post
title: "변수선언과 데이터 할당"
category: frontend
description: >
  변수 선언과 데이터 할당에 대하여
image:
  path: /assets/img/frontend/ES6.png  
tags: JavaScript TIL
---


<!--more-->

# 변수 선언과 데이터 할당
{:.no_toc}

* this list will be replaced by the toc
{:toc .large-only}


- **변수 선언** : 변수를 정의하는 것을 의미

```jsx
var developer;
```

- **변수 할당** : 변수가 선언된 후 대입 연산자(=)를 통해 값을 넣어주는 것을 의미

```jsx
var developer;
developer = "eunseok";
```

- **변수 초기화 :** 변수를 선언함과 동시에 값을 넣어 주는 것을 의미

```jsx
var developer = "eunseok";
```

## 자바스크립트에서 메모리의 데이터 할당은 어떻게 이루어질까?

위 코드에서 자바스크립트는 몇가지 작업을 수행합니다.

1. `developer`이라는 변수를 선언합니다.
2. 문자열에 대한 메모리를 할당합니다.
3. 할당된 메모리에서 'eunseok' 이라는 문자열을 저장합니다.
4. '`developer`'에서 메모리의 해당 문자열에 대한 참조를 생성합니다.

### 💡메모리의 구조는?

![다운로드 (2).png](/assets/img/frontend/memorys.png)

1. **메모리 셀과 바이트**
   - 컴퓨터 메모리는 실제로 메모리 셀로 구성됩니다. 이러한 셀은 비트로 `1` 또는 `0`이 될 수 있는 이진 단위입니다. 8개의 비트가 모여 컴퓨터 시스템의 기본 데이터 단위인 1바이트를 형성합니다.
2. **메모리 주소 지정**
   - 각 메모리 셀(또는 정의에 따라 각 바이트)에는 실제로 고유한 주소가 있습니다. CPU는 이 주소를 사용하여 메모리에서 데이터를 읽고 메모리에 데이터를 씁니다.
3. **CPU와 메모리 상호 작용**:
   - CPU는 실제로 메모리에서 명령과 데이터를 가져오고 레지스터의 데이터에 대한 명령을 실행한 다음 결과를 다시 메모리에 저장합니다. 이를 **fetch-decode-execute(**프로그램 실행 구조)라고 합니다.
4. **대용량 데이터**
   - 단일 바이트에 저장할 수 없는 더 큰 데이터 값은 실제로 여러 바이트(또는 정의에 따라 여러 메모리 셀)에 걸쳐 저장됩니다.
5. **대용량 데이터 읽기**
   - 많은 양의 데이터가 여러 메모리 위치에 저장되어 있는 경우 올바르게 읽는 데 필요한 것은 데이터의 첫 번째 바이트 주소와 데이터 길이(바이트)입니다

### 그 외 메모리에 대해서

- **메모리 유형**
  - 컴퓨터에는 RAM(Random Access Memory), ROM(Read-Only Memory), 캐시 메모리, 가상 메모리 등 다양한 유형의 메모리가 있습니다. 각 유형의 메모리에는 고유한 용도가 있습니다
- **메모리 계층 구조**
  - 컴퓨터 시스템의 메모리는 비용과 속도 사이의 균형을 반영하는 계층 구조로 구성됩니다. 예를 들어 CPU 내부의 레지스터는 가장 빠르지만 가장 비싼 유형의 메모리인 반면, 하드 드라이브는 느리지만 저렴한 비용으로 많은 양의 스토리지를 제공합니다.
- **메모리 관리**
  - 운영 체제는 컴퓨터의 메모리 관리를 담당합니다. 사용 중인 메모리 부분을 추적하고 프로세스가 요청할 때 메모리를 할당하고 더 이상 필요하지 않으면 할당을 해제합니다.
- **주소 지정 모드**
  - CPU는 다른 주소 지정 모드를 사용하여 필요한 데이터를 찾을 수 있습니다. 예를 들어 직접 주소 지정(데이터 주소를 직접 지정), 간접 주소 지정(데이터 주소를 다른 주소에 저장) 등을 사용할 수 있습니다.

다시 돌아와서 자바스크립트에서 기본형데이터타입 과 참조형데이터타입은 메모리 할당 방식이 다릅니다.

## (1)기본형 데이터타입 메모리 할당

**기본형 데이터타입**인 String을 변수선언을 하였을때

```jsx
let str = "Hello, World!";
```

이를 "값으로 전달" 또는 "값으로 저장"이라고 합니다.

그리고 위 경우 변수 `str`은 `"Hello, World!"` 값을 직접 보유합니다. 새 변수에 `str`을 할당하면 값의 복사본이 만들어지고 새 변수에 저장됩니다

```jsx
let str2 = str;
```

`str2`는 `"Hello, World!"`도 포함합니다. 그러나 `str`과 `str2`는 완전히 별개입니다. 하나를 변경해도 다른 하나는 영향을 받지 않습니다.

예를들어 메모리를 가시적으로 표현한다면 아래와 같습니다.

| 주소   | …   | 1002                    | 1003  | 1004            | 1005 | …   |
| ------ | --- | ----------------------- | ----- | --------------- | ---- | --- |
| 데이터 |     | 변수이름:str ,참조:5004 |       |                 |      |     |
| 주소   | …   | 5002                    | 5003  | 5004            | 5005 | …   |
| 데이터 |     | //~~~                   | //~~~ | “Hello, World!” |      |     |

위 에서 기술한바와같이

1. `str`이라는 변수를 선언합니다.
2. 문자열에 대한 메모리를 할당합니다.
3. 할당된 메모리에서 'Hello, World!' 라는 문자열을 저장합니다.
4. '`str`'에서 메모리의 해당 문자열에 대한 참조를 생성합니다.

### 왜 변수값을 바로 대입하지않나요 ??

값을 바로 변수에 대입하지 않는 이유(=무조건 새로 만드는 이유)

- 자유로운 데이터 변환
  - 이미 입력한 문자열이 길어진다면 뒤에 주소들을 한칸씩 다미뤄야함
  - 숫자는 항상 8byte로 고정이지만, 문자는 고정이 아닙니다,(영문 : 1byte, 한글 : 2byte). 그래서 할당된 데이터보다 훨씬 더큰 데이터를 변경해주려면 매우 많은 메모리셀이 필요
- 메모리의 효율적 관리
  - 똑같은 데이터를 여러번 저장해야 한다면?
  - 1만개의 변수를 생성해서 모든 변수에 숫자 1을 할당하는 상황을 가정해 봅시다. 모든 변수를 별개로 인식한다고 한다면, 1만개의 변수 공간을 확보해야 합니다.
    - 바로 대입하는 case) 숫자형은 8 바이트 고정이죠?
      - 1만개 \* 8byte = **8만 byte**
    - 변수 영역에 별도 저장 case)
      - 변수 영역 : 2바이트 1만개 = \*\*\*\*2만바이트
      - 데이터 영역 : 8바이트 1개 = 8바이트
      - 총 : **2만 8바이트**

## (2)참조형 데이터타입 메모리할당

| 주소   | …   | 1002                | 1003  | 1004 | 1005 | …   |
| ------ | --- | ------------------- | ----- | ---- | ---- | --- |
| 데이터 |     | obj /참조 7103~7104 |       |      |      |     |
| 주소   | …   | 5002                | 5003  | 5004 | 5005 | …   |
| 데이터 |     | 1                   | ‘bbb’ |      |      |     |

**기본형 데이터타입과 참조형 데이터타입의 메모리할당 과정의 차이점은 : 객체의 변수 (property) 영역의 별도 존재 여부입니다**

| 주소   | …   | 7103            | 7104           | 7105 | …   |
| ------ | --- | --------------- | -------------- | ---- | --- |
| 데이터 |     | a , 참조 : 5002 | b , 참조: 5003 |      |     |

```jsx
var obj1 = {
	a: 1,
	b: 'bbb,
};
```

**참조형 데이터가 불변하지 않다**라는 이유 : `obj1.a = 2` 라는 코드가있을 경우

1. 5004번 주소에 2 값이 새로 할당되고
2. 7103번 주소에 5004번으로 참조가 바뀐다.
3. 그리고 5002 번값은 **가비지 - 컬렉터**에의해 수거가 된다.

### 참조카운트란 무엇일까요?

<aside>
💡 **객체를 참조하는 변수나 다른 객체의 수를 나타내는 값**입니다. 참조 카운트가 0인 객체는 더 이상 사용되지 않으므로, **가비지 컬렉터**에 의해 메모리에서 제거됩니다.

</aside>

### 가비지컬렉터(GC, Garbage Collector)

<aside>
💡 더 이상 사용되지 않는 객체를 자동으로 메모리에서 제거하는 역할을 합니다. 자바스크립트는 가비지 컬렉션을 수행함으로써 개발자가 명시적으로 메모리 관리를 하지 않아도 되도록 지원합니다. 자바스크립트 엔진에서 내부적으로 수행되며, 개발자는 가비지 컬렉션에 대한 직접적인 제어를 할 수 없습니다.

</aside>

### 변수 복사의 비교

```jsx
var a = 10; //기본형
var obj1 = { c: 10, d: "ddd" }; //참조형

var b = a; //기본형
var obj2 = obj1; //참조형
```

| 주소   | 1001   | 1002           | 1003 | 1004 | 1005 | …   |
| ------ | ------ | -------------- | ---- | ---- | ---- | --- |
| 데이터 | a/5001 | obj1/7103~7014 |      |      |      |     |
| 주소   | 5001   | 5002           | 5003 | 5004 | 5005 |     |
| 데이터 | 10     | 10             | ddd  |      |      |     |

| 주소   | 7103     | 7104    | …   |
| ------ | -------- | ------- | --- |
| 데이터 | c / 5002 | d/ 5003 |     |

### 복사 이후 값 변경(객체의 프로퍼티 변경)

```jsx
var a = 10; //기본형
var obj1 = { c: 10, d: "ddd" }; //참조형

var b = a; //기본형
var obj2 = obj1; //참조형

b = 15;
obj2.c = 20;
```

기본형과 참조형의 변수 복사 시 주요한 절차의 차이점

- 기본형
  - 숫자 15라는 값을 데이터 영역에서 검색 후 없다면 생성
  - 검색한 결과주소 또는 생성한 주소를 변수 영역 b에 갈아끼움
  - a와 b는 서로 다른 데이터 영역의 주소를 바라보고 있기 때문에 **`영향 없음`**
- 참조형

  - 숫자 20이라는 값을 데이터 영역에서 검색 후 없다면 생성
  - 검색한 결과주소 또는 생성한 주소 obj2에게 지정되어 있는 별도 영역(7103~)에 갈아끼움
  - obj1도 똑같은 주소를 바라보고 있기 때문에 **`obj1까지 변경이 됨`**

  ```jsx
  // 기본형 변수 복사의 결과는 다른 값!
  a !== b;

  // 참조형 변수 복사의 결과는 같은 값!(원하지 않았던 결과😭)
  obj1 === obj2;
  ```

